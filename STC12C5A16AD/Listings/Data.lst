C51 COMPILER V9.60.0.0   DATA                                                              03/01/2022 15:27:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DATA
OBJECT MODULE PLACED IN .\Objects\Data.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Data.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC12C5A16AD) DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\Data.lst) TABS(1) OBJECT(.\Objects\Data.obj)

line level    source

   1          #include "Data.h"
   2          
   3          void Uart_Isr() interrupt 4
   4          {
   5   1          if (RI)
   6   1          {
   7   2              RI = 0;
   8   2              R_Data[R_Num] = SBUF;
   9   2              if (R_Data[0] == 0xFD)
  10   2              {
  11   3                  R_Num++;
  12   3                  if ((R_Data[1] + 2) == R_Num)
  13   3                  {
  14   4                      R_CL++;
  15   4                      R_Num = 0;
  16   4                      R_Data[0] = 0;
  17   4                  }
  18   3              }
  19   2              else
  20   2              {
  21   3                  R_Num = 0;
  22   3              }
  23   2          }
  24   1      }
  25          
  26          void DATA_CL() //接收到的数据进行效验处理
  27          {
  28   1       uchar idata SUM = 0xFD, num, i[21];
  29   1       while (R_CL)
  30   1       {
  31   2        for (num = 1; num < R_Data[1] + 1; num++)
  32   2        {
  33   3         SUM = SUM + R_Data[num];
  34   3        }
  35   2        if (SUM == R_Data[num])
  36   2        {
  37   3         for (num = 0; num < R_Data[1] - 1; num++)
  38   3         {
  39   4          i[num] = R_Data[num + 2];
  40   4         }
  41   3       //  DATA_Que(i);
  42   3        }
  43   2        else
  44   2        {
  45   3         i[0] = 0xfd;
  46   3         i[1] = 0x03;
  47   3         i[2] = 0x90;
  48   3         i[3] = 0xff;
  49   3         i[4] = 0xa0;
  50   3         UART_Send(i, 5);
  51   3        }
  52   2        R_CL--;
  53   2       }
  54   1      }
C51 COMPILER V9.60.0.0   DATA                                                              03/01/2022 15:27:40 PAGE 2   

  55          
  56          void DATA_Que(uchar *i) //接收到有效数据，分类并处理
  57          {
  58   1       uchar idata j[5] = {0xfd, 0x03, 0x90, 0x10, 0xa0};
  59   1       if (i[0] == 0x01) //设置参数
  60   1       {
  61   2        IapEraseSector(0x2000); //扇区擦除
  62   2        IapEraseSector(0x2200);
  63   2        IapEraseSector(0x2400);
  64   2        IapEraseSector(0x2600);
  65   2        IapEraseSector(0x2800);
  66   2        IapEraseSector(0x2a00);
  67   2        IapEraseSector(0x2c00);
  68   2        IapEraseSector(0x2e00);
  69   2        IapProgramuchar(0x2000, i[1]); //电机数
  70   2        IapProgramuchar(0x2001, i[2]); //扩展口电机/定位选择
  71   2        UART_Send(j, 5);
  72   2       }
  73   1       else if (i[0] >= 0x10 && i[0] <= 0x1f) //设置定位参数
  74   1       {
  75   2        i[0] = i[0] - 0x10;
  76   2        IapProgramuchar(0x2010 + i[0], i[1]); //定位1 端口选择 2010-201F
  77   2        IapProgramuchar(0x2020 + i[0], i[2]); //定位2 端口选择 2020-202F
  78   2        UART_Send(j, 5);
  79   2       }
  80   1       else if (i[0] == 0x20) //程序段总数
  81   1       {
  82   2        IapProgramuchar(0x2030, i[1]); //程序0段总段数
  83   2        IapProgramuchar(0x2031, i[2]); //程序1段总段数
  84   2        IapProgramuchar(0x2032, i[3]); //程序2段总段数
  85   2        UART_Send(j, 5);
  86   2       }
  87   1       else if (i[0] == 0x21) //程序0段写入
  88   1       {
  89   2        uchar k, l;
  90   2        for (k = 0, l = 19; k < 19; k++, l--)
  91   2        {
  92   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2100, i[k + 2]); //循环写入数据 2100-25F9里
  93   3        }
  94   2        UART_Send(j, 5);
  95   2       }
  96   1       else if (i[0] == 0x22) //程序1段写入
  97   1       {
  98   2        uchar k, l;
  99   2        for (k = 0, l = 19; k < 19; k++, l--)
 100   2        {
 101   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2600, i[k + 2]); //循环写入数据 2600-2AF9里
 102   3        }
 103   2        UART_Send(j, 5);
 104   2       }
 105   1       else if (i[0] == 0x23) //程序2段写入
 106   1       {
 107   2        uchar k, l;
 108   2        for (k = 0, l = 19; k < 19; k++, l--)
 109   2        {
 110   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2b00, i[k + 2]); //循环写入数据 2b00-2FF9里
 111   3        }
 112   2        UART_Send(j, 5);
 113   2       }
 114   1       else if (i[0] == 0x30) //电机定位状态返回
 115   1       {
 116   2        if (i[1] == 1)
C51 COMPILER V9.60.0.0   DATA                                                              03/01/2022 15:27:40 PAGE 3   

 117   2        {
 118   3         T_Flag = 1;
 119   3        }
 120   2        else
 121   2        {
 122   3         T_Flag = 0;
 123   3        }
 124   2       }
 125   1       else if (i[0] == 0x31) //强制停止
 126   1       {
 127   2        if (i[1] == 1)
 128   2        {
 129   3         IAP_CONTR = 0X20;
 130   3        }
 131   2       }
 132   1       else if (i[0] == 0x32 || i[0] == 0x35) //单段程序启动
 133   1       {
 134   2        uchar j;
 135   2        for (j = 0; j < 18; j++)
 136   2        {
 137   3         P_Rom[j] = i[j + 1];
 138   3        }
 139   2      
 140   2       }
 141   1       else if (i[0] == 0x33) //程序位置返回
 142   1       {
 143   2      
 144   2       }
 145   1       else if (i[0] == 0x65) //下载完成 并重启
 146   1       {
 147   2        if (i[1] == 0x10)
 148   2        {
 149   3         IAP_CONTR = 0X20; //重启单片机
 150   3        }
 151   2       }
 152   1       else if (i[0] == 0xa0) //上传标志
 153   1       {
 154   2      
 155   2       }
 156   1       else if (i[0] == 0x90) //数据是否正确
 157   1       {
 158   2        
 159   2       }
 160   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    917    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----      28
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
