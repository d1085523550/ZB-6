C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 08:57:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DATA
OBJECT MODULE PLACED IN .\Objects\Data.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Data.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC12C5A16AD) DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\Data.lst) TABS(1) OBJECT(.\Objects\Data.obj)

line level    source

   1          #include "Data.h"
   2          
   3          void Uart_Isr() interrupt 4
   4          {
   5   1       if (RI)
   6   1       {
   7   2        RI = 0;
   8   2        R_Data[R_Num] = SBUF;
   9   2        if (R_Data[0] == 0xFD)
  10   2        {
  11   3         R_Num++;
  12   3         if ((R_Data[1] + 2) == R_Num)
  13   3         {
  14   4          R_CL++;
  15   4          R_Num = 0;
  16   4          R_Data[0] = 0;
  17   4         }
  18   3        }
  19   2        else
  20   2        {
  21   3         R_Num = 0;
  22   3        }
  23   2       }
  24   1      }
  25          
  26          void DATA_CL() //接收到的数据进行效验处理
  27          {
  28   1       uchar idata SUM = 0xFD, num, i[21];
  29   1       while (R_CL)
  30   1       {
  31   2        for (num = 1; num < R_Data[1] + 1; num++)
  32   2        {
  33   3         SUM = SUM + R_Data[num];
  34   3        }
  35   2        if (SUM == R_Data[num])
  36   2        {
  37   3         for (num = 0; num < R_Data[1] - 1; num++)
  38   3         {
  39   4          i[num] = R_Data[num + 2];
  40   4         }
  41   3         DATA_Que(i);
  42   3        }
  43   2        else
  44   2        {
  45   3         i[0] = 0xfd;
  46   3         i[1] = 0x03;
  47   3         i[2] = 0x90;
  48   3         i[3] = 0xff;
  49   3         i[4] = 0xa0;
  50   3         UART_Send(i, 5);
  51   3        }
  52   2        R_CL--;
  53   2       }
  54   1      }
C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 08:57:04 PAGE 2   

  55          
  56          void DATA_Que(uchar *i) //接收到有效数据，分类并处理
  57          {
  58   1       uchar idata j[5] = {0xfd, 0x03, 0x90, 0x10, 0xa0};
  59   1       switch (i[0])
  60   1       {
  61   2       case 0x01:
  62   2        IapEraseSector(0x2000); //扇区擦除
  63   2        IapEraseSector(0x2200);
  64   2        IapEraseSector(0x2400);
  65   2        IapEraseSector(0x2600);
  66   2        IapEraseSector(0x2800);
  67   2        IapEraseSector(0x2a00);
  68   2        IapEraseSector(0x2c00);
  69   2        IapEraseSector(0x2e00);
  70   2        IapProgramuchar(0x2000, i[1]); //电机数
  71   2        IapProgramuchar(0x2001, i[2]); //扩展口电机/定位选择
  72   2        UART_Send(j, 5);
  73   2        break;
  74   2       }
  75   1       if (i[0] == 0x01) //设置参数
  76   1       {
  77   2        IapEraseSector(0x2000); //扇区擦除
  78   2        IapEraseSector(0x2200);
  79   2        IapEraseSector(0x2400);
  80   2        IapEraseSector(0x2600);
  81   2        IapEraseSector(0x2800);
  82   2        IapEraseSector(0x2a00);
  83   2        IapEraseSector(0x2c00);
  84   2        IapEraseSector(0x2e00);
  85   2        IapProgramuchar(0x2000, i[1]); //电机数
  86   2        IapProgramuchar(0x2001, i[2]); //扩展口电机/定位选择
  87   2        UART_Send(j, 5);
  88   2       }
  89   1       else if (i[0] >= 0x10 && i[0] <= 0x1f) //设置定位参数
  90   1       {
  91   2        i[0] = i[0] - 0x10;
  92   2        IapProgramuchar(0x2010 + i[0], i[1]); //定位1 端口选择 2010-201F
  93   2        IapProgramuchar(0x2020 + i[0], i[2]); //定位2 端口选择 2020-202F
  94   2        UART_Send(j, 5);
  95   2       }
  96   1       else if (i[0] == 0x20) //程序段总数
  97   1       {
  98   2        IapProgramuchar(0x2030, i[1]); //程序0段总段数
  99   2        IapProgramuchar(0x2031, i[2]); //程序1段总段数
 100   2        IapProgramuchar(0x2032, i[3]); //程序2段总段数
 101   2        UART_Send(j, 5);
 102   2       }
 103   1       else if (i[0] == 0x21) //程序0段写入
 104   1       {
 105   2        uchar k, l;
 106   2        for (k = 0, l = 19; k < 19; k++, l--)
 107   2        {
 108   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2100, i[k + 2]); //循环写入数据 2100-25F9里
 109   3        }
 110   2        UART_Send(j, 5);
 111   2       }
 112   1       else if (i[0] == 0x22) //程序1段写入
 113   1       {
 114   2        uchar k, l;
 115   2        for (k = 0, l = 19; k < 19; k++, l--)
 116   2        {
C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 08:57:04 PAGE 3   

 117   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2600, i[k + 2]); //循环写入数据 2600-2AF9里
 118   3        }
 119   2        UART_Send(j, 5);
 120   2       }
 121   1       else if (i[0] == 0x23) //程序2段写入
 122   1       {
 123   2        uchar k, l;
 124   2        for (k = 0, l = 19; k < 19; k++, l--)
 125   2        {
 126   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2b00, i[k + 2]); //循环写入数据 2b00-2FF9里
 127   3        }
 128   2        UART_Send(j, 5);
 129   2       }
 130   1       else if (i[0] == 0x30) //电机定位状态返回
 131   1       {
 132   2        if (i[1] == 1)
 133   2        {
 134   3         T_Flag = 1;
 135   3        }
 136   2        else
 137   2        {
 138   3         T_Flag = 0;
 139   3        }
 140   2       }
 141   1       else if (i[0] == 0x31) //强制停止
 142   1       {
 143   2        if (i[1] == 1)
 144   2        {
 145   3         IAP_CONTR = 0X20;
 146   3        }
 147   2       }
 148   1       else if (i[0] == 0x32 || i[0] == 0x35) //单段程序启动
 149   1       {
 150   2        uchar j;
 151   2        for (j = 0; j < 18; j++)
 152   2        {
 153   3         P_Rom[j] = i[j + 1];
 154   3        }
 155   2       }
 156   1       else if (i[0] == 0x33) //程序位置返回
 157   1       {
 158   2       }
 159   1       else if (i[0] == 0x65) //下载完成 并重启
 160   1       {
 161   2        if (i[1] == 0x10)
 162   2        {
 163   3         IAP_CONTR = 0X20; //重启单片机
 164   3        }
 165   2       }
 166   1       else if (i[0] == 0xa0) //上传标志
 167   1       {
 168   2       }
 169   1       else if (i[0] == 0x90) //数据是否正确
 170   1       {
 171   2       }
 172   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1051    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 08:57:04 PAGE 4   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----      28
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
