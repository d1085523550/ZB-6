C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DATA
OBJECT MODULE PLACED IN .\Objects\Data.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE Data.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC12C5A16AD) DEBUG OBJECTEXTEND 
                    -PRINT(.\Listings\Data.lst) TABS(2) OBJECT(.\Objects\Data.obj)

line level    source

   1          #include "Data.h"
   2          
   3          void Uart_Isr() interrupt 4
   4          {
   5   1        if (RI)
   6   1        {
   7   2          RI = 0;
   8   2          R_Data[R_Num] = SBUF;
   9   2          if (R_Data[0] == 0xFD)
  10   2          {
  11   3            R_Num++;
  12   3            if ((R_Data[1] + 2) == R_Num)
  13   3            {
  14   4              R_CL++;
  15   4              R_Num = 0;
  16   4              R_Data[0] = 0;
  17   4            }
  18   3          }
  19   2          else
  20   2          {
  21   3            R_Num = 0;
  22   3          }
  23   2        }
  24   1      }
  25          
  26          void DATA_CL() //接收到的数据进行效验处理
  27          {
  28   1        uchar idata SUM = 0xFD, num, i[13];
  29   1        if (R_CL)
  30   1        {
  31   2          for (num = 1; num < R_Data[1] + 1; num++)
  32   2          {
  33   3            SUM = SUM + R_Data[num];
  34   3          }
  35   2          if (SUM == R_Data[num])
  36   2          {
  37   3            for (num = 0; num < R_Data[1] - 1; num++)
  38   3            {
  39   4              i[num] = R_Data[num + 2];
  40   4            }
  41   3            DATA_Que(i);
  42   3          }
  43   2          else
  44   2          {
  45   3            i[0] = 0xFD;
  46   3            i[1] = 0x03;
  47   3            i[2] = 0xA0;
  48   3            i[3] = 0x00;
  49   3            i[4] = 0xA0;
  50   3            UART_Send(i, 5);
  51   3          }
  52   2          R_CL--;
  53   2        }
  54   1      }
C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 2   

  55          
  56          void DATA_Que(uchar *i) //接收到有效数据，分类并处理
  57          {
  58   1        uchar idata j[5] = {0xFD, 0x03, 0xA0, 0x10, 0xB0};
  59   1        uchar k, l;
  60   1        switch (i[0])
  61   1        {
  62   2        case 0x00: //握手信号
  63   2          j[3] = 0xF0;
  64   2          j[4] = 0x90;
  65   2          UART_Send(j, 5);
  66   2          IapEraseSector(0x2000); //扇区擦除
  67   2          IapEraseSector(0x2200);
  68   2          IapEraseSector(0x2400);
  69   2          IapEraseSector(0x2600);
  70   2          IapEraseSector(0x2800);
  71   2          IapEraseSector(0x2a00);
  72   2          IapEraseSector(0x2c00);
  73   2          IapEraseSector(0x2e00);
  74   2          IapEraseSector(0x3000);
  75   2          IapEraseSector(0x3200);
  76   2          j[3] = 0x10;
  77   2          j[4] = 0xb0;
  78   2          UART_Send(j, 5);
  79   2          break;
  80   2        case 0x01:               //设置参数
  81   2          IapProgramuchar(0x2001, i[2]); //扩展口电机/定位选择
  82   2          UART_Send(j, 5);
  83   2          break;
  84   2        case 0x02: //设置定位参数
  85   2        case 0x03:
  86   2        case 0x04:
  87   2        case 0x05:
  88   2        case 0x06:
  89   2        case 0x07:
  90   2        case 0x08:
  91   2        case 0x09:
  92   2        case 0x0A:
  93   2        case 0x0B:
  94   2        case 0x0C:
  95   2        case 0x0D:
  96   2        case 0x0E:
  97   2        case 0x0F:
  98   2        case 0x10:
  99   2        case 0x11:
 100   2          IapProgramuchar(0x2000 + i[0], i[1]); //定位1 端口选择 2002-2011
 101   2          IapProgramuchar(0x2010 + i[0], i[2]); //定位2 端口选择 2012-2021
 102   2          UART_Send(j, 5);
 103   2          break;
 104   2        case 0x12: //动作名称
 105   2        case 0x13:
 106   2        case 0x14:
 107   2        case 0x15:
 108   2        case 0x16:
 109   2        case 0x17:
 110   2        case 0x18:
 111   2        case 0x19:
 112   2        case 0x1A:
 113   2        case 0x1B:
 114   2        case 0x1C:
 115   2        case 0x1D:
 116   2        case 0x1E:
C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 3   

 117   2        case 0x1F:
 118   2        case 0x20:
 119   2        case 0x21:
 120   2          for (k = 0; k < 12; k++)
 121   2          {
 122   3            IapProgramuchar(0x2022 + (i[0] - 0x12) * 12 + k, i[k + 1]);
 123   3          }
 124   2          UART_Send(j, 5);
 125   2          break;
 126   2        case 0x22:               //程序段总数
 127   2          IapProgramuchar(0x20E2, i[1]); //程序0段总段数
 128   2          IapProgramuchar(0x20E3, i[2]); //程序1段总段数
 129   2          IapProgramuchar(0x20E4, i[3]); //程序2段总段数
 130   2          UART_Send(j, 5);
 131   2          break;
 132   2        case 0x23: //程序0段写入
 133   2          for (k = 0, l = 9; k < 9; k++, l--)
 134   2          {
 135   3            IapProgramuchar((i[1] + 1) * 9 - l + 0x2100, i[k + 2]); //循环写入数据 2100-25F9里
 136   3          }
 137   2          UART_Send(j, 5);
 138   2          break;
 139   2        case 0x24: //程序1段写入
 140   2          for (k = 0, l = 9; k < 9; k++, l--)
 141   2          {
 142   3            IapProgramuchar((i[1] + 1) * 9 - l + 0x2755, i[k + 2]); //循环写入数据 2600-2AF9里
 143   3          }
 144   2          UART_Send(j, 5);
 145   2          break;
 146   2        case 0x25: //程序2段写入
 147   2          for (k = 0, l = 9; k < 9; k++, l--)
 148   2          {
 149   3            IapProgramuchar((i[1] + 1) * 9 - l + 0x2DAA, i[k + 2]); //循环写入数据 2b00-2FF9里
 150   3          }
 151   2          UART_Send(j, 5);
 152   2          break;
 153   2        case 0x26: //下载完成 并重启
 154   2          if (i[1] == 0xF0)
 155   2          {
 156   3            IAP_CONTR = 0X20; //重启单片机
 157   3          }
 158   2          break;
 159   2        case 0x30: //电机定位状态返回
 160   2          if (i[1] == 1)
 161   2          {
 162   3            T_Flag = 1;
 163   3          }
 164   2          else
 165   2          {
 166   3            T_Flag = 0;
 167   3          }
 168   2          break;
 169   2        case 0x31: //强制停止
 170   2          if (i[1] == 1)
 171   2          {
 172   3            IAP_CONTR = 0X20;
 173   3          }
 174   2          break;
 175   2        case 0x32: //单段程序启动
 176   2        case 0x35:
 177   2          for (k = 0; k < 18; k++)
 178   2          {
C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 4   

 179   3            P_Rom[k] = i[k + 1];
 180   3          }
 181   2          break;
 182   2        case 0x33: //程序位置返回
 183   2          break;
 184   2        case 0x2B: //上传标志
 185   2          if (i[1] == 1)
 186   2          {
 187   3            T_YZ = 1;
 188   3          }
 189   2          else
 190   2          {
 191   3            i[0] = 0xFD;
 192   3            i[1] = 0x03;
 193   3            i[2] = 0xA0;
 194   3            i[3] = 0x00;
 195   3            i[4] = 0xA0;
 196   3            UART_Send(i, 5);
 197   3          }
 198   2          break;
 199   2        case 0xA0: //数据验证
 200   2        {
 201   3          if (i[1] == 0x10)
 202   3          {
 203   4            T_Step++;
 204   4            T_Step_Temp = T_Step;
 205   4          }
 206   3          else if (i[1] == 0x00)
 207   3          {
 208   4            T_Step_Temp = T_Step;
 209   4          }
 210   3        }
 211   2        default:
 212   2          i[0] = 0xFD;
 213   2          i[1] = 0x03;
 214   2          i[2] = 0xA0;
 215   2          i[3] = 0x00;
 216   2          i[4] = 0xA0;
 217   2          UART_Send(i, 5);
 218   2          break;
 219   2        }
 220   1      }
 221          
 222          void SendData()
 223          {
 224   1        uchar idata i[16], k;
 225   1        i[0] = 0xfd;
 226   1        i[2] = 0x4f + T_Step_Temp;
 227   1        switch (T_Step_Temp)
 228   1        {
 229   2        case 1:
 230   2          i[1] = 0x03;
 231   2          i[2] = 0x50;
 232   2          i[3] = IapReaduchar(0x2001);
 233   2          i[4] = i[0] + i[1] + i[2] + i[3];
 234   2          UART_Send(i, 5);
 235   2          break;
 236   2        case 2:
 237   2        case 3:
 238   2        case 4:
 239   2        case 5:
 240   2        case 6:
C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 5   

 241   2        case 7:
 242   2        case 8:
 243   2        case 9:
 244   2        case 10:
 245   2        case 11:
 246   2        case 12:
 247   2        case 13:
 248   2        case 14:
 249   2        case 15:
 250   2        case 16:
 251   2        case 17:
 252   2          i[1] = 0x04;
 253   2          i[3] = IapReaduchar(0x2000 + T_Step_Temp);
 254   2          i[4] = IapReaduchar(0x2010 + T_Step_Temp);
 255   2          i[5] = i[0] + i[1] + i[2] + i[3] + i[4];
 256   2          UART_Send(i, 6);
 257   2          break;
 258   2        case 18:
 259   2        case 19:
 260   2        case 20:
 261   2        case 21:
 262   2        case 22:
 263   2        case 23:
 264   2        case 24:
 265   2        case 25:
 266   2        case 26:
 267   2        case 27:
 268   2        case 28:
 269   2        case 29:
 270   2        case 30:
 271   2        case 31:
 272   2        case 32:
 273   2        case 33:
 274   2          i[1] = 16;
 275   2          for (k = 0; k < 12; k++)
 276   2          {
 277   3            i[k + 3] = IapReaduchar(0x2022 + (T_Step_Temp - 18) * 12 + k);
 278   3          }
 279   2          i[15] = i[0] + i[1] + i[2] + i[3] + i[4] + i[5] + i[6] + i[7] + i[8] + i[9] + i[10] + i[11] + i[12] + i[
             -13] + i[14];
 280   2          UART_Send(i, 16);
 281   2          break;
 282   2        case 34:
 283   2          i[1] = 14;
 284   2          for (k = 0; k < 9; k++)
 285   2          {
 286   3            
 287   3          }
 288   2          break;
 289   2        case 35:
 290   2          break;
 291   2        case 36:
 292   2          break;
 293   2        }
 294   1        T_Step_Temp = 0;
 295   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1510    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   DATA                                                              03/08/2022 17:01:37 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----      37
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
