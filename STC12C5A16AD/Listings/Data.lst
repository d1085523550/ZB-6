C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 11:41:16 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DATA
OBJECT MODULE PLACED IN .\Objects\Data.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Data.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC12C5A16AD) DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\Data.lst) TABS(1) OBJECT(.\Objects\Data.obj)

line level    source

   1          #include "Data.h"
   2          
   3          void Uart_Isr() interrupt 4
   4          {
   5   1       if (RI)
   6   1       {
   7   2        RI = 0;
   8   2        R_Data[R_Num] = SBUF;
   9   2        if (R_Data[0] == 0xFD)
  10   2        {
  11   3         R_Num++;
  12   3         if ((R_Data[1] + 2) == R_Num)
  13   3         {
  14   4          R_CL++;
  15   4          R_Num = 0;
  16   4          R_Data[0] = 0;
  17   4         }
  18   3        }
  19   2        else
  20   2        {
  21   3         R_Num = 0;
  22   3        }
  23   2       }
  24   1      }
  25          
  26          void DATA_CL() //接收到的数据进行效验处理
  27          {
  28   1       uchar idata SUM = 0xFD, num, i[21];
  29   1       while (R_CL)
  30   1       {
  31   2        for (num = 1; num < R_Data[1] + 1; num++)
  32   2        {
  33   3         SUM = SUM + R_Data[num];
  34   3        }
  35   2        if (SUM == R_Data[num])
  36   2        {
  37   3         for (num = 0; num < R_Data[1] - 1; num++)
  38   3         {
  39   4          i[num] = R_Data[num + 2];
  40   4         }
  41   3         DATA_Que(i);
  42   3        }
  43   2        else
  44   2        {
  45   3         i[0] = 0xfd;
  46   3         i[1] = 0x03;
  47   3         i[2] = 0x90;
  48   3         i[3] = 0xff;
  49   3         i[4] = 0xa0;
  50   3         UART_Send(i, 5);
  51   3        }
  52   2        R_CL--;
  53   2       }
  54   1      }
C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 11:41:16 PAGE 2   

  55          
  56          void DATA_Que(uchar *i) //接收到有效数据，分类并处理
  57          {
  58   1       uchar idata j[5] = {0xfd, 0x03, 0x90, 0x10, 0xa0};
  59   1       uchar k, l;
  60   1       switch (i[0])
  61   1       {
  62   2       case 0x01:     //设置参数
  63   2        IapEraseSector(0x2000); //扇区擦除
  64   2        IapEraseSector(0x2200);
  65   2        IapEraseSector(0x2400);
  66   2        IapEraseSector(0x2600);
  67   2        IapEraseSector(0x2800);
  68   2        IapEraseSector(0x2a00);
  69   2        IapEraseSector(0x2c00);
  70   2        IapEraseSector(0x2e00);
  71   2        IapProgramuchar(0x2000, i[1]); //电机数
  72   2        IapProgramuchar(0x2001, i[2]); //扩展口电机/定位选择
  73   2        UART_Send(j, 5);
  74   2        break;
  75   2      
  76   2       case 0x10: //设置定位参数
  77   2       case 0x11:
  78   2       case 0x12:
  79   2       case 0x13:
  80   2       case 0x14:
  81   2       case 0x15:
  82   2       case 0x16:
  83   2       case 0x17:
  84   2       case 0x18:
  85   2       case 0x19:
  86   2       case 0x1a:
  87   2       case 0x1b:
  88   2       case 0x1c:
  89   2       case 0x1d:
  90   2       case 0x1e:
  91   2       case 0x1f:
  92   2        i[0] = i[0] - 0x10;
  93   2        IapProgramuchar(0x2010 + i[0], i[1]); //定位1 端口选择 2010-201F
  94   2        IapProgramuchar(0x2020 + i[0], i[2]); //定位2 端口选择 2020-202F
  95   2        UART_Send(j, 5);
  96   2        break;
  97   2       case 0x20:         //程序段总数
  98   2        IapProgramuchar(0x2030, i[1]); //程序0段总段数
  99   2        IapProgramuchar(0x2031, i[2]); //程序1段总段数
 100   2        IapProgramuchar(0x2032, i[3]); //程序2段总段数
 101   2        UART_Send(j, 5);
 102   2        break;
 103   2       case 0x21: //程序0段写入
 104   2        for (k = 0, l = 19; k < 19; k++, l--)
 105   2        {
 106   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2100, i[k + 2]); //循环写入数据 2100-25F9里
 107   3        }
 108   2        UART_Send(j, 5);
 109   2        break;
 110   2       case 0x22: //程序1段写入
 111   2        for (k = 0, l = 19; k < 19; k++, l--)
 112   2        {
 113   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2600, i[k + 2]); //循环写入数据 2600-2AF9里
 114   3        }
 115   2        UART_Send(j, 5);
 116   2        break;
C51 COMPILER V9.60.0.0   DATA                                                              03/02/2022 11:41:16 PAGE 3   

 117   2       case 0x23: //程序2段写入
 118   2        for (k = 0, l = 19; k < 19; k++, l--)
 119   2        {
 120   3         IapProgramuchar((i[1] + 1) * 19 - l + 0x2b00, i[k + 2]); //循环写入数据 2b00-2FF9里
 121   3        }
 122   2        UART_Send(j, 5);
 123   2        break;
 124   2       case 0x30: //电机定位状态返回
 125   2        if (i[1] == 1)
 126   2        {
 127   3         T_Flag = 1;
 128   3        }
 129   2        else
 130   2        {
 131   3         T_Flag = 0;
 132   3        }
 133   2        break;
 134   2       case 0x31: //强制停止
 135   2        if (i[1] == 1)
 136   2        {
 137   3         IAP_CONTR = 0X20;
 138   3        }
 139   2        break;
 140   2       case 0x32: //单段程序启动
 141   2       case 0x35:
 142   2        for (k = 0; k < 18; k++)
 143   2        {
 144   3         P_Rom[k] = i[k + 1];
 145   3        }
 146   2        break;
 147   2       case 0x33: //程序位置返回
 148   2        break;
 149   2       case 0x65: //下载完成 并重启
 150   2        if (i[1] == 0x10)
 151   2        {
 152   3         IAP_CONTR = 0X20; //重启单片机
 153   3        }
 154   2        break;
 155   2       case 0xa0: //上传标志
 156   2        break;
 157   2       case 0x90: //数据是否正确
 158   2        break;
 159   2       }
 160   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    907    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----      28
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
